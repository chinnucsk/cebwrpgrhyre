% Problem12:
% The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
% 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
% Let us list the factors of the first seven triangle numbers:
%      1: 1
%      3: 1,3
%      6: 1,2,3,6
%     10: 1,2,5,10
%     15: 1,3,5,15
%     21: 1,3,7,21
%     28: 1,2,4,7,14,28
% We can see that 28 is the first triangle number to have over five divisors.
% What is the value of the first triangle number to have over five hundred divisors?

-module (euler12).

-export ([start/0]).

-define (N_DIVISORS, 500).

% NOTE: Naive solution.

start() ->
	Answer = find_target_triangle_number(0, 0),
	io:format("Answer: ~w~n", [Answer]).

find_target_triangle_number(TriangleNumber, SeqNum) ->
	case is_target_triangle_number(TriangleNumber, 1, 1) of % black magic: the already found divisor is to compensate for the last division
		true ->
			TriangleNumber;
		false ->
			Next = SeqNum + 1,
			find_target_triangle_number(next_triangle_number(TriangleNumber, Next), Next)
	end.
is_target_triangle_number(_, _, NDivisors) when NDivisors =:= ?N_DIVISORS ->
	true;
is_target_triangle_number(TriangleNumber, Divisor, NDivisors) when Divisor > TriangleNumber div 2 ->
	case NDivisors > 200 of 
		true ->
			io:format("Found number with NDivisors: ~w~n", [NDivisors]);
		_ ->
			dfdfdf
	end,
	false;
is_target_triangle_number(TriangleNumber, Divisor, NDivisors) when NDivisors < ?N_DIVISORS ->
	case TriangleNumber rem Divisor of 
		0 ->
			is_target_triangle_number(TriangleNumber, Divisor + 1, NDivisors + 1);
		_ ->
			is_target_triangle_number(TriangleNumber, Divisor + 1, NDivisors)
	end.	 	

next_triangle_number(PrevNumber, SeqNum) ->
	PrevNumber + SeqNum.